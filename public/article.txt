Executive Summary
With open source libraries, companies can now create apps that can scale on demand to over 1 billion users — at a cost of only 1-5% compared to using Amazon AWS, Google Cloud (e.g. Firebase), and Microsoft Azure — thereby maximizing profitability. This article provides eight concrete steps that your company can take to achieve profitable growth by saving up to 99% of technology costs.
The Profitability Problem
Evernote is emblematic of the profitability problem. Evernote has struggled to achieve profitability even after acquiring hundreds of millions of users with more than a $100 million per year in revenue. Evernote's struggle is far from being an outlier. Rather, it is unfortunately the norm. However, the good news is that with proper planning, companies can avoid the mistakes that Evernote made — mistakes which far too many companies still continue to make.
To put it more concretely, with proper planning, a company can find itself incurring only 1-5% of the technology costs during its growth stage compared to what it would otherwise be spending without sufficient foresight. Below are eight concrete steps that your company can take to dramatically reduce technology cost, complexity, and customer support issues — attaining maximum profitability as a result.
Design your databases to scale horizontally right from the start.
Vertical scaling cost increases exponentially whereas with horizontal scalability cost is linear. (Vertical scaling means "adding more power to existing machines", while horizontal scaling means "adding more machines.") In fact, horizontal scaling must be the mantra for all technology decisions right out of the gate; and only properly designed software can scale horizontally.
Consider the following all-too-common database design. Many web developers are trained to use auto incrementing numbers as ID's for the contents of table rows. But this approach cannot scale horizontally. If you split the load so that multiple servers are adding new rows, the numerical IDs of one server can conflict with the numerical ID of another, causing catastrophic results.
Care must be taken at the start to make each server's assignment of ID's stateless, so that resources can later be effortlessly distributed amongst an increasing number of servers as the company grows. At the start, at the very least tag all users with an immutable user ID and then tag all their resources based upon that immutable ID. That way user resources can continually be redistributed in horizontal fashion as your user base continues to grow — all with predictable, linear incremental costs.
Plan shareable code for web, iOS, Android, Windows, and Mac right from the start.
In fact, if your app is database-driven and/or API-driven, create one single code base for all of the above. Only in recent years has this even been possible, and by taking advantage of modern libraries you can avoid numerous technical difficulties that inevitably negatively impact customer experience as well.
Consider Evernote as a perfect case in point. "Evernote had five different apps run by five different teams for five different platforms, and each had its own set of features, design touches and technical issues. Internally, Evernote employees called the app's codebase 'the monolith,' and that monolith had grown so big and complex, it was preventing the company from shipping cross-platform features or doing much of anything in a short time." (Source)
Evernote was founded in 2004. Today, almost twenty years later, companies now have the option of selecting a single code base for web, mobile, and desktop (with the notable exception of two types of apps: utilities for the given platform, and apps that require CPU intensive graphics such as 3D rendering and animation). The vast majority of apps do not require native operating system programming and design. However, the choice of hybrid development is extremely important.
For example, it is possible to write a mobile app using Flutter, and then convert the Flutter app to a web app. However, the resulting web app will likely experience significant performance issues. Yet, if you start with an Ionic web app, your company can have highly performant iOS and Android apps with zero additional coding and expenditure as a result. Importantly, your apps performance will rival, if not exceed, that which you could achieve by writing the iOS/Android apps in React Native.
There is an urban legend that React Native inherently produces more performant apps. But the real-world truth is that this is simply a myth. Unlike React Native apps, Ionic apps take advantage of Just-in-Time (JIT) compiling. Most mobile apps are continually running (as opposed to using Javascript to write short-term scripts), and therefore they make abundant use of the performance benefits of JIT compilation. In a recent head to head comparison of React Native vs Ionic, where React Native was attempting to consume 200% CPU, the Ionic equivalent was only consuming 10% CPU. This not only affects the visual performance, but also dramatically impacts battery life as well.
This is not to say that Ionic is a one-size fits all solution. But it is strongly recommended that your company looks at this alternative as a first option. If there is a technologically compelling reason to select something else, it is wise for the selection process to still focus on maximizing sharable libraries/API calls right at the start. For example, if the front-end is going to require multiple code bases, then perhaps a larger degree of functionality can be relegated to the server via shared REST APIs.
Design your web app using industry-standard UI for mobile apps, even if you plan on only starting with a web app.
This will be extremely important when you decided to convert your web app into a mobile app — most especially in terms of an iOS app. Apple disallows mobile apps that do not conform to industry standard mobile styling and navigation. In recent court filings in response to a lawsuit by Epic Games, Apple disclosed that it rejects over one third of all apps submitted, resulting in rejecting over 1.5 million apps per year (close to 2 million apps per year at present).
Numerous developers have reported spending months trying to get their apps approved by Apple with a significant number giving up. Yet, Apple's criteria is not magic. Apple's standards are clearly defined, and adhering to those standards at the start will allow your company to immediately deploy your web app as an iOS app in the Apple Store (provided you also plan in accordance with the next step immediately below). A practical way to achieve this step is to use Ionic styling for your web app while adhering to best-practice mobile navigation patterns.
Implement your web app with mobile wrappers for storage and other device access, even if you are starting solely with a web app.
Apple disallows apps that can be run entirely on the web. It is a standard rejection. Said another way, your mobile app must make use of the device's features in a manner that provides some utility that the web cannot.
A simple way to achieve this is to use mobile wrapper functions even when creating the web app. For example, typical web apps often use something called Local Storage — a service for storing information via the browser. However, if all Local Storage browser API calls are replaced with an equivalent mobile function call (such as the Storage API from Capacitor) then the web app would still use Local Storage, yet when the app is converted to iOS and Android then the native device storage will end up being used instead. This, in and of itself, is often sufficient to avoid the standard rejection of being a web app that is merely disguised as a native app.
The same applies if your app is going to use the webcam or other device components. Wrap all such calls using Capacitor, Cordova, Phone Gap, or the like.
Build your own horizontally-scalable Pub/Sub architecture deployable on Linux virtual servers.
Almost every successful company is going to need some form of real-time messaging, if not other real-time features. Such real-time updates are typically accomplished using a Pub/Sub model (a "publish" and "subscribe" model). For example, in a group chat, all members subscribe to the chat channel. Then, whenever a member publishes a message, that message gets sent to all the subscribers in real time.
Another example is a financial app that has a continual, real-time stock feed. Your apps subscribe to this feed, and the stock prices are published to that feed (causing all the subscribers to receive the updated feed in real time). There are many companies offering real-time update services (such as Google's Firebase platform). However, if your company or app needs to scale any real-time service proportionately to your user base then strongly consider building your own horizontally-scalable Pub/Sub architecture (even hire a consultant to do it for you to incur a single, one-time cost).
Companies such as PubNub (launched in 2010) were founded when browser support for Web Sockets was in its infancy (the browser Web Socket API is often used for Pub/Sub functionality). Today, off-the-shelf, open-source libraries exist. For example, by combining Socket.io with Redis, a developer can quickly build a horizontally scalable Pub/Sub infrastructure deployable on Linux virtual servers. The first version of Socket.io was itself launched in 2010. With the advent of the Socket.io Redis adapter, it now provides horizontal scalability. Recent years have seen two other libraries eclipse Socket.io: SockJs and WS. In fact, WS now has over 59 million weekly downloads — making it a popular, stable, well-supported alternative.
Having your own Pub/Sub architecture gives you far more control and flexibility than any third party can provide. It also gives you the ability to control costs — which is directly related to the immediately following step (reducing cloud egress costs).
Pay extremely close attention to network egress costs — the cash cow of most infrastructure-as-a-service platforms.
Network egress costs alone can make or break the corporate piggy bank. Network egress refers to data which leaves a cloud service to go to an internet connected device. For example, consider a group chat with 100 users. When a user publishes a message, that message is sent to the cloud service. This incoming message is not counted as a cost. However, when that message is sent out of the cloud service to the 99 other members, those egress transmissions are charged to the corporate account.
Most cloud service providers charge network egress usage for all services, not just Pub/Sub. Microsoft Azure currently offers 100GB egress free per month, and then charges 8-12 cents per GB thereafter (depending on the destination — where the data is being sent to). Amazon AWS and Google have similar pricing. However, now consider Linode's pricing. A $5 per month shared-CPU virtual server includes 1TB of network egress with each additional GB charged at 1 cent each. If Microsoft, Google, and Amazon average 10 cents per GB, you would pay $90 to match the 1TB included in the Linode package (as the first 100GB is free for each of them). That does not account for the fact that you also need to pay for storage with the Microsoft, Google, and Amazon to cover the storage included in the Linode package. That does not account for the fact that Linode's price per each additional GB overage is literally 10% of Microsoft, Google, and Amazon.
If you built your own Pub/Sub architecture in accordance with the prior step then you can take advantage of the pricing of virtual server providers such as Linode, Vultr, and more. In fact, you can save even more money for streaming resources such as videos as explained immediately below.
When it comes to selecting infrastructure, it is important to separate horizontally scaling services from static streaming resources (such as video). If your company needs to scale a service on-the-fly in direct proportion to its user base, then programmatically buildable virtual servers are the ideal platform (e.g. Linode, Vultr). However, if your company is going to be streaming video or other static resources, these resources are best served by dedicated servers at companies such as High Velocity. For example, currently your company can get a powerful, multi-CPU, 16 core, 32 thread server with 480GB SSD storage for just $189 per month. Very importantly, this server includes 100TB of network transfer at a guaranteed 1Gbps. At Microsoft, Google, and Amazon your company would spend close to $10,000 just for the equivalent egress, and then pay additionally for the 480GB of storage. I have personally worked with High Velocity for many years, and can vouch that their customer service is the best in the industry.
Using a hybrid approach, dividing your resources based on functionality and network egress requirements, your company can literally reduce expenditures by more than 99%. When it comes to network egress, pay close attention to the fine print.
Use standardized APIs where possible.
Content-delivery networks (CDNs) have revolutionized the web. With a content-delivery network, users access files from servers that are nearby, greatly reducing latency and thereby greatly improving customer experience. To do this, CDNs replicate the files to servers they have deployed around the globe.
Most CDN providers support the S3 API for file upload and delivery. By using this API, your company can use the lowest cost CDN that matches your committed Service Level Agreement (SLA). Should you need to switch CDNs for any reason, doing so is trivial. There is no change to the code, just a change to a configuration file.
The cost savings here are so significant that your company could simultaneously use the S3 API to send identical copies of the files to Amazon AWS, thereby creating a fault tolerant service should the primary CDN provider experience any issues such as a network outage. Because the file copies are going to Amazon AWS, your company does not incur any egress costs whatsoever. Nevertheless, you now have a fault tolerant CDN delivery for pennies on the dollar compared to using Amazon AWS as the primary CDN service.
This same principle applies to other APIs as well. Wherever possible, use shared APIs to both radically reduce costs while improving performance at the same time (e.g. establish a fault-tolerant CDN model).
Decouple core functions from the underlying service through judicious use of interface functions.
Where common shared APIs do not exist, always have your applications make requests through interface functions instead of directly accessing the service provider's API. The objective of the free tiers and other enticements from service providers is to get your company locked in, dependent on that service. Then, as you reach the growth stage, your company is beholden to the provider, having to accept the ever increasing costs.
Vendor lock-in can largely be avoided through proper planning by employing interface functions — functions that translate the app's request to the current service provider's API.
Conclusion
Remarkably, many startups can avoid up to 99% technology costs during the growth stage, but it does take some planning right at the beginning. A central theme of this article is that startups need to design IT, data communications, and web development together as one cohesive whole. A well-planned rollout will be extremely inexpensive in the beginning (in many cases less than $50 per month) while able to horizontally scale on demand to 100 million (even 1 billion) users — all in a linear, predictable manner — resulting in maximum profitability, and far fewer customer support issues to boot.